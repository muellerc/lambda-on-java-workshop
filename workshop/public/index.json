[
{
	"uri": "/",
	"title": "Lambda On Java Workshop",
	"tags": [],
	"description": "",
	"content": " Welcome Builders! Why are we here? Customers who are running their AWS Lambda functions on Java are constantly struggling with the the so called \u0026ldquo;function cold-start\u0026rdquo;. The function cold start is the time the AWS Lambda services needs to provisioning and start the underlying runtime environment, when it\u0026rsquo;s called the first time or when the concurrent execution increases.\nIn this session I will share with you, how you can optimizations your Java based AWS Lambda functions, so that you will see a shorter cold-starts and a higher P99 performance.\nThis workshop is composed of 3 parts:\nIn the first part, we will measure the performance baseline, based on a service implementation running in AWS Fargate behind an Application load balancer. As a second baseline, we will measure the performance of a service implementation in Python. After that, we will see how we can significantly improve the performance by moving away from Springboot.\nIn the second part, we will have a look at many approaches, how we could improve the performance of our service. Some are more successful then others, and when we combine all of them, we see another remarkable performance improvement.\nLast but not least, we will have a look at GraalVM, a polyglot virtual machine which come with the capability to compile your Java code to native-code. Let\u0026rsquo;s see whether and how this can help us to reduce the latency even further.\nOur imaginary service This is the high-level architecture of our current service implementation. Behind an Application Load Balancer, we are using 2 AWS Fargate container which hosts our Springboot application. This application stores pet data in Amazon DynamoDB and the medical record for each pet in Amazon S3.\nIf we have a closer look into our service implementation, we will see it\u0026rsquo;s a typical Springboot application. Our controller takes the incoming requests and routes them based on path-matching to the corresponding service class, which contains our business logic. This service implementations uses a repository and a store as persistence layer, to store the pets and medical records.\n"
},
{
	"uri": "/set-up.html",
	"title": "Set-Up",
	"tags": [],
	"description": "",
	"content": " The following CloudFormation template should be executed by an IAM user with Administrator privileges, not the root account user. Please ensure you are logged in as an IAM user, not the root account user.\n Set-up the environment We will leverage AWS CloudFormation which allows us to codify our infrastructure. In addition, we use AWS SAM to build serverless applications in simple and clean syntax.\n1. Execute the AWS CloudFormation stack in your closest region  Frankfurt Ireland Oregon  Create your AWS Cloud9 Environment by launching this CloudFormation template in Frankfurt, with clicking on the below Launch button.\n   AWS CloudFormation launch template Launch in Frankfurt     AWS Cloud9 IDE  Launch      Create your AWS Cloud9 Environment by launching this CloudFormation template in Ireland, with clicking on the below Launch button.\n   AWS CloudFormation launch template Launch in Ireland     AWS Cloud9 IDE  Launch      Create your AWS Cloud9 Environment by launching this CloudFormation template in Oregon, with clicking on the below Launch button.\n   AWS CloudFormation launch template Launch in Oregon     AWS Cloud9 IDE  Launch       $(function(){$(\"#region\").tabs();}); 2. Launch the AWS CloudFormation stack Acknowledge that AWS CloudFormation might create IAM resources and click the Create Stack button to launch the template.\n3. Wait until the AWS CloudFormation stack launched It takes usually less than 2 minutes until the stack launched. When the stack is launched, the status will change from CREATE_IN_PROGRESS to CREATE_COMPLETE.\n4. Browse to your AWS Cloud9 development environment Ad blockers, javascript disabler, and tracking blockers should be disabled for the cloud9 domain, or connecting to the workspace might be impacted. Cloud9 requires third-party-cookies. You can whitelist the specific domains.\n The Outputs tab in your CloudFormation console exposes the Cloud9DevEnvUrl parameter. Click at the corresponding URL in the value column and open your AWS Cloud9 development environment in a new tab.\n5. Configure your AWS Cloud9 development environment In your AWS Cloud9 IDE, you can close the welcome tab. In the left environment navigation window, you can see the project lambda-on-java-workshop we have already checked out for you from Github. This project also contains a shell script to update the OS and to install additional tools like GraalVM, Scala and Gatling. Run the following command in the bash window at the bottom of the AWS Cloud9 IDE:\nchmod +x ~/environment/lambda-on-java-workshop/labs/set-up/configureCloud9.sh ~/environment/lambda-on-java-workshop/labs/set-up/configureCloud9.sh source ~/.bashrc It takes usually ~ 3 minutes, until the OS is updated and all tools are installed.\nAs we want to compare our results with an equivalent implementation in Python, let\u0026rsquo;s build the Python 3.6 based service first by running the following command in in the bash window in AWS Cloud9:\ncd ~/environment/lambda-on-java-workshop/labs/lab-1-replatform/python-lambda sam build Now we continue with building all Java based service implementations, by running the following command in the AWS Cloud9 IDE bash window:\ncd ~/environment/lambda-on-java-workshop/labs chmod +x ./mvnw ./mvnw clean package It takes usually ~ 12 minutes, until all projects are build and packaged.\n"
},
{
	"uri": "/set-up/measurement.html",
	"title": "Measurement",
	"tags": [],
	"description": "",
	"content": " How do we measure performance \u0026amp; throughput To determine the behavior under load, we are running a load test for 1 minute, starting with 1 user (which determines the concurrency) and increase it linearly, until we reached 20 users after one minute (meaning we are increasing the concurrency by 1 after each 3 seconds for 1 minute). We are running this test 10 times per service implementation against a new deployed instance and report the best result.\nTo determine the cold-start time, we are measure 10 cold-starts and report the best one for each service implementation.\nThe load test is running in an AWS Cloud9 instance (m5.large) in the same region as we have deployed our services.\nGatling We are using the Scala based load generating tool Gatling to load test our different service implementations. Each service comes with a Scala based load test in the folder src/test/scala/xxxLoadTest.scala.\nIn a future version, we may integrate the load test scenario directly into our Maven project, leveraging the Gatling Maven Plugin.\nAt the end of a load test, Gatling creates a nice report about the performance and throughput from a client perspective:\nTo get started with Gatling, please follow the Quickstart and the Advanced Tutorial.\nAmazon X-Ray In addition, we are using AWS X-Ray to sample some requests to get better insights where we spend our time by processing these requests.\nJavaagent Instrumentation Because we have situations where we don\u0026rsquo;t want or cannot use Amazon X-Ray, we use Javaagent Instrumentation in addition to get better insights.\nYou will get similar output like this (package names dropped), which gives you an idea where you spend most of the time executing the request. You have to specify the classes, which should be instrumented:\nApacheHttpClient.createClient(ApacheHttpClient$DefaultBuilder,AttributeMap) : 323 DefaultDynamoDbClient.init(BaseAwsJsonProtocolFactory$Builder) : 79 ObjectMapper._findRootDeserializer(DeserializationContext,JavaType) : 140 ObjectMapper._readMapAndClose(JsonParser,JavaType) : 142 ObjectMapper.readValue(String,JavaType) : 161 ObjectMapper.readValue(java.lang.String,java.lang.Class) : 165 ApacheHttpClient.execute(HttpRequestBase) : 429 ApacheHttpClient.access$500(ApacheHttpClient,HttpRequestBase) : 429 DefaultDynamoDbClient.putItem(PutItemRequest) : 707 ApacheHttpClient.execute(HttpRequestBase) : 251 ApacheHttpClient.access$500(ApacheHttpClient,HttpRequestBase) : 251 DefaultS3Client.putObject(PutObjectRequest,RequestBody) : 329 CreatePetLambdaHandler.handleRequest(APIGatewayV2ProxyRequestEvent,Context) : 1428"
},
{
	"uri": "/replatform.html",
	"title": "Replatform",
	"tags": [],
	"description": "",
	"content": " Overview In this section, we first determine our performance baseline for this service, so that we have the necessary data to know, whether and how we improved the performance of this service in a particular implementation.\nAs baseline, we will measure the performance for the service implementation which is running behind an Application Load Balancer in AWS Fargate.\nAs additional references we will\n"
},
{
	"uri": "/replatform/springboot2-fargate.html",
	"title": "Springboot2 in Fargate",
	"tags": [],
	"description": "",
	"content": " Analyze The Deployment Package To determine the package size of your function, run the following command in the bash window in your AWS Cloud9 IDE:\ncd ~/environment/lambda-on-java-workshop/labs ls -lh lab-1-replatform/springboot2-fargate/target/app.jar It will report a package size of 42 MB.\nDeploy The Application First, we have to build our Docker image and upload it to Amazon ECR, our private image registry:\n$(aws ecr get-login --no-include-email --region REPLACE_ME_WITH_YOUR_REGION) aws ecr create-repository --repository-name spring-fargate cd ~/environment/lambda-on-java-workshop/labs/labslab-1-replatform/springboot2-fargate docker build -t spring-fargate . docker tag spring-fargate:latest REPLACE_ME_WITH_YOUR_AWS_ACCOUNT_ID.dkr.ecr.REPLACE_ME_WITH_YOUR_REGION.amazonaws.com/spring-fargate:latest docker push REPLACE_ME_WITH_YOUR_AWS_ACCOUNT_ID.dkr.ecr.REPLACE_ME_WITH_YOUR_REGION.amazonaws.com/spring-fargate:latest Last, we have to update the file ~/environment/lambda-on-java-workshop/labs/lab-1-replatform/springboot2-fargate/template.yaml with your AWS account id and region:\nImage: !Sub 'REPLACE_ME_WITH_YOUR_AWS_ACCOUNT_ID.dkr.ecr.REPLACE_ME_WITH_YOUR_REGION.amazonaws.com/spring-fargate:latest'  To deploy the application, run the following command. It also exports the service endpoint url and the function ARN as environment variables for easy access:\ncd ~/environment/lambda-on-java-workshop/labs sam package --template-file lab-1-replatform/springboot2-fargate/template.yaml \\  --output-template-file lab-1-replatform/springboot2-fargate/packaged.yaml \\  --s3-bucket $SAM_ARTIFACT_BUCKET sam deploy --template-file lab-1-replatform/springboot2-fargate/packaged.yaml \\  --stack-name springboot2-fargate \\  --capabilities CAPABILITY_IAM export ENDPOINT=$(aws cloudformation describe-stacks \\  --stack-name springboot2-fargate \\  --query \u0026#39;Stacks[].Outputs[?OutputKey==`PetsApiServiceURL`].OutputValue\u0026#39; \\  --output text) export FUNCTION_ARN=$(aws cloudformation describe-stacks \\  --stack-name springboot2-fargate \\  --query \u0026#39;Stacks[].Outputs[?OutputKey==`CreatePetLambdaHandlerFunction`].OutputValue\u0026#39; \\  --output text) Memory Configuration We choose to go with 1024 MB for the load and performance tests.\nRun The Load Tests export JAVA_OPTS=\u0026#34;-DBASE_URL=$ENDPOINT\u0026#34; for i in {1..10}; do aws lambda update-function-configuration --function-name $FUNCTION_ARN --environment \u0026#34;Variables={TABLE_NAME=$PETS_TABLE,BUCKET_NAME=$PETS_BUCKET,KeyName1=KeyValue$i}\u0026#34;; gatling.sh --simulations-folder lab-1-replatform/springboot2-fargate/src/test/scala --simulation LoadTest --run-description \u0026#34;springboot2-fargate-run-$i\u0026#34;; done Run the Cold-Start Tests for i in {1..10}; do aws lambda update-function-configuration --function-name $FUNCTION_ARN --environment \u0026#34;Variables={TABLE_NAME=$PETS_TABLE,BUCKET_NAME=$PETS_BUCKET,KeyName1=KeyValue$i}\u0026#34;; curl -i -X POST -H \u0026#39;content-type: application/json\u0026#39; -d \u0026#39;{\u0026#34;name\u0026#34;: \u0026#34;Max\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;dog\u0026#34;, \u0026#34;birthday\u0026#34;: \u0026#34;2010-11-03\u0026#34;, \u0026#34;medicalRecord\u0026#34;: \u0026#34;bla bla bla\u0026#34;}\u0026#39; $ENDPOINT/pet; done Result Overview Gatling Load Test Result (best out of 10)     Source Code Yo can find the source code here.\n"
},
{
	"uri": "/replatform/springboot2-lambda.html",
	"title": "Springboot2 Lambda",
	"tags": [],
	"description": "",
	"content": " Analyze The Deployment Package To determine the package size of your function, run the following command in the bash window in your AWS Cloud9 IDE:\ncd ~/environment/lambda-on-java-workshop/labs ls -lh lab-1-replatform/springboot2-lambda/target/springboot2-lambda.jar It will report a package size of 39 MB.\nDeploy The Application To deploy the application, run the following command. It also exports the service endpoint url and the function ARN as environment variables for easy access:\nsam package --template-file lab-1-replatform/springboot2-lambda/template.yaml \\  --output-template-file lab-1-replatform/springboot2-lambda/packaged.yaml \\  --s3-bucket $SAM_ARTIFACT_BUCKET sam deploy --template-file lab-1-replatform/springboot2-lambda/packaged.yaml \\  --stack-name springboot2-lambda \\  --capabilities CAPABILITY_IAM export ENDPOINT=$(aws cloudformation describe-stacks \\  --stack-name springboot2-lambda \\  --query \u0026#39;Stacks[].Outputs[?OutputKey==`PetsApiServiceURL`].OutputValue\u0026#39; \\  --output text) export FUNCTION_ARN=$(aws cloudformation describe-stacks \\  --stack-name springboot2-lambda \\  --query \u0026#39;Stacks[].Outputs[?OutputKey==`CreatePetLambdaHandlerFunction`].OutputValue\u0026#39; \\  --output text) Memory Configuration We choose to go with 1024 MB for the load and performance tests.\n  Run The Load Tests export JAVA_OPTS=\u0026#34;-DBASE_URL=$ENDPOINT\u0026#34; for i in {1..10}; do aws lambda update-function-configuration --function-name $FUNCTION_ARN --environment \u0026#34;Variables={TABLE_NAME=$PETS_TABLE,BUCKET_NAME=$PETS_BUCKET,KeyName1=KeyValue$i}\u0026#34;; gatling.sh --simulations-folder lab-1-replatform/springboot2-lambda/src/test/scala --simulation LoadTest --run-description \u0026#34;springboot2-lambda-run-$i\u0026#34;; done Run the Cold-Start Tests for i in {1..10}; do aws lambda update-function-configuration --function-name $FUNCTION_ARN --environment \u0026#34;Variables={TABLE_NAME=$PETS_TABLE,BUCKET_NAME=$PETS_BUCKET,KeyName1=KeyValue$i}\u0026#34;; curl -i -X POST -H \u0026#39;content-type: application/json\u0026#39; -d \u0026#39;{\u0026#34;name\u0026#34;: \u0026#34;Max\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;dog\u0026#34;, \u0026#34;birthday\u0026#34;: \u0026#34;2010-11-03\u0026#34;, \u0026#34;medicalRecord\u0026#34;: \u0026#34;bla bla bla\u0026#34;}\u0026#39; $ENDPOINT/pet; done Result Overview Gatling Load Test Result (best out of 10)     Amazon X-Ray Cold-Start Trace (best out of 10)   Source Code Yo can find the source code here.\n"
},
{
	"uri": "/replatform/python-lambda.html",
	"title": "Python Lambda",
	"tags": [],
	"description": "",
	"content": " Analyze The Deployment Package To determine the package size of your function, run the following command in the bash window in your AWS Cloud9 IDE:\ncd ~/environment/lambda-on-java-workshop/labs ls -lh lab-1-replatform/python-lambda/.aws-sam/build/CreatePetLambdaHandlerFunction It will report a package size of 666 bytes (112 KB uncompressed).\nDeploy The Application To deploy the application, run the following command. It also exports the service endpoint url and the function ARN as environment variables for easy access:\nsam package --template-file lab-1-replatform/python-lambda/template.yaml \\  --output-template-file lab-1-replatform/python-lambda/packaged.yaml \\  --s3-bucket $SAM_ARTIFACT_BUCKET sam deploy --template-file lab-1-replatform/python-lambda/packaged.yaml \\  --stack-name python-lambda \\  --capabilities CAPABILITY_IAM export ENDPOINT=$(aws cloudformation describe-stacks \\  --stack-name python-lambda \\  --query \u0026#39;Stacks[].Outputs[?OutputKey==`PetsApiServiceURL`].OutputValue\u0026#39; \\  --output text) export FUNCTION_ARN=$(aws cloudformation describe-stacks \\  --stack-name python-lambda \\  --query \u0026#39;Stacks[].Outputs[?OutputKey==`CreatePetLambdaHandlerFunction`].OutputValue\u0026#39; \\  --output text) Memory Configuration We choose to go with 1024 MB for the load and performance tests.\n  Run The Load Tests export JAVA_OPTS=\u0026#34;-DBASE_URL=$ENDPOINT\u0026#34; for i in {1..10}; do aws lambda update-function-configuration --function-name $FUNCTION_ARN --environment \u0026#34;Variables={TABLE_NAME=$PETS_TABLE,BUCKET_NAME=$PETS_BUCKET,KeyName1=KeyValue$i}\u0026#34;; gatling.sh --simulations-folder lab-1-replatform/python-lambda/src/test/scala --simulation LoadTest --run-description \u0026#34;python-lambda-run-$i\u0026#34;; done Run the Cold-Start Tests for i in {1..10}; do aws lambda update-function-configuration --function-name $FUNCTION_ARN --environment \u0026#34;Variables={TABLE_NAME=$PETS_TABLE,BUCKET_NAME=$PETS_BUCKET,KeyName1=KeyValue$i}\u0026#34;; curl -i -X POST -d \u0026#39;{\u0026#34;name\u0026#34;: \u0026#34;Max\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;dog\u0026#34;, \u0026#34;birthday\u0026#34;: \u0026#34;2010-11-03\u0026#34;, \u0026#34;medicalRecord\u0026#34;: \u0026#34;bla bla bla\u0026#34;}\u0026#39; $ENDPOINT/pet; done Result Overview Gatling Load Test Result (best out of 10)     Amazon X-Ray Cold-Start Trace (best out of 10)   Source Code Yo can find the source code here.\n"
},
{
	"uri": "/replatform/dagger2-lambda.html",
	"title": "Dagger2 Lambda",
	"tags": [],
	"description": "",
	"content": " Analyze The Deployment Package To determine the package size of your function, run the following command in the bash window in your AWS Cloud9 IDE:\ncd ~/environment/lambda-on-java-workshop/labs ls -lh lab-1-replatform/dagger2-lambda/target/app.jar It will report a package size of 8.9 MB.\nTo be able to run your function locally to analyse it in more detail, export your AWS_REGION as following:\nexport AWS_REGION=$(aws --profile default configure get region) To determine the number of classes which gets loaded to execute your function, run the following command in the bash window in your AWS Cloud9 IDE. Each application contains a helper Main class which invokes your AWS Lambda function locally:\njava -cp lab-1-replatform/dagger2-lambda/target/app.jar -verbose:class Main | grep \u0026#39;\\[Loaded\u0026#39; | wc -l It will report 4516 classes got loaded to execute your AWS Lambda function.\nTo get a breakdown by package name, run the following command:\njava -cp lab-1-replatform/dagger2-lambda/target/app.jar -verbose:class Main | grep \u0026#39;\\[Loaded\u0026#39; | grep \u0026#39;.jar\\]\u0026#39; | sed \u0026#39;s/\\[Loaded \\([^A-Z]*\\)[\\$A-Za-z0-9]* from .*\\]/\\1/g\u0026#39; | sort | uniq -c | sort You can run an instrumented version of your function which measure the execution time for all methods in the most interesting classes by running the following command:\njava -cp lab-1-replatform/dagger2-lambda/target/app.jar -javaagent:java-instrumentation-1.0-SNAPSHOT.jar=instrumentation.cfg Main You will a similar output like this (package names dropped), which gives you an idea where you spend most of the time:\nObjectMapper._findRootDeserializer(DeserializationContext,JavaType) : 190 ObjectMapper._readMapAndClose(JsonParser,JavaType) : 194 ObjectMapper.readValue(URL,Class) : 222 ObjectMapper._readMapAndClose(JsonParser,JavaType) : 61 ObjectMapper.readValue(URL,Class) : 62 ObjectMapper._findRootDeserializer(DeserializationContext,JavaType) : 53 ObjectMapper._readMapAndClose(JsonParser,JavaType) : 79 ObjectMapper.readValue(URL,Class) : 80 ObjectMapper._findRootDeserializer(DeserializationContext,JavaType) : 56 ObjectMapper._readMapAndClose(JsonParser,JavaType) : 175 ObjectMapper.readValue(InputStream,Class) : 175 CreatePetLambdaHandler.handleRequest(APIGatewayV2ProxyRequestEvent,Context) : 1555 Deploy The Application To deploy the application, run the following command. It also exports the service endpoint url and the function ARN as environment variables for easy access:\nsam package --template-file lab-1-replatform/dagger2-lambda/template.yaml \\  --output-template-file lab-1-replatform/dagger2-lambda/packaged.yaml \\  --s3-bucket $SAM_ARTIFACT_BUCKET sam deploy --template-file lab-1-replatform/dagger2-lambda/packaged.yaml \\  --stack-name dagger2-lambda \\  --capabilities CAPABILITY_IAM export ENDPOINT=$(aws cloudformation describe-stacks \\  --stack-name dagger2-lambda \\  --query \u0026#39;Stacks[].Outputs[?OutputKey==`PetsApiServiceURL`].OutputValue\u0026#39; \\  --output text) export FUNCTION_ARN=$(aws cloudformation describe-stacks \\  --stack-name dagger2-lambda \\  --query \u0026#39;Stacks[].Outputs[?OutputKey==`CreatePetLambdaHandlerFunction`].OutputValue\u0026#39; \\  --output text) Memory Configuration We choose to go with 1024 MB for the load and performance tests.\n  Run The Load Tests export JAVA_OPTS=\u0026#34;-DBASE_URL=$ENDPOINT\u0026#34; for i in {1..10}; do aws lambda update-function-configuration --function-name $FUNCTION_ARN --environment \u0026#34;Variables={TABLE_NAME=$PETS_TABLE,BUCKET_NAME=$PETS_BUCKET,KeyName1=KeyValue$i}\u0026#34;; gatling.sh --simulations-folder lab-1-replatform/dagger2-lambda/src/test/scala --simulation LoadTest --run-description \u0026#34;dagger2-lambda-run-$i\u0026#34;; done Run the Cold-Start Tests for i in {1..10}; do aws lambda update-function-configuration --function-name $FUNCTION_ARN --environment \u0026#34;Variables={TABLE_NAME=$PETS_TABLE,BUCKET_NAME=$PETS_BUCKET,KeyName1=KeyValue$i}\u0026#34;; curl -i -X POST -d \u0026#39;{\u0026#34;name\u0026#34;: \u0026#34;Max\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;dog\u0026#34;, \u0026#34;birthday\u0026#34;: \u0026#34;2010-11-03\u0026#34;, \u0026#34;medicalRecord\u0026#34;: \u0026#34;bla bla bla\u0026#34;}\u0026#39; $ENDPOINT/pet; done Result Overview Gatling Load Test Result (best out of 10)     Amazon X-Ray Cold-Start Trace (best out of 10)   Source Code Yo can find the source code here.\n"
},
{
	"uri": "/replatform/no-di-framework-lambda.html",
	"title": "No DI Framework Lambda",
	"tags": [],
	"description": "",
	"content": " Analyze The Deployment Package To determine the package size of your function, run the following command in the bash window in your AWS Cloud9 IDE:\ncd ~/environment/lambda-on-java-workshop/labs ls -lh lab-1-replatform/no-di-framework-lambda/target/app.jar It will report a package size of 8.9 MB.\nTo be able to run your function locally to analyse it in more detail, export your AWS_REGION as following:\nexport AWS_REGION=$(aws --profile default configure get region) To determine the number of classes which gets loaded to execute your function, run the following command in the bash window in your AWS Cloud9 IDE. Each application contains a helper Main class which invokes your AWS Lambda function locally:\n# Java 8 java -cp lab-1-replatform/no-di-framework-lambda/target/app.jar -verbose:class Main | grep \u0026#39;\\[Loaded\u0026#39; | wc -l# Java 11 java -cp lab-1-replatform/no-di-framework-lambda/target/app.jar -verbose:class Main | grep \u0026#39;\\[class,load\\]\u0026#39; | wc -l It will report 4890 classes got loaded to execute your AWS Lambda function.\nTo get a breakdown by package name, run the following command:\n# Java 8 java -cp lab-1-replatform/no-di-framework-lambda/target/app.jar -verbose:class Main | grep \u0026#39;\\[Loaded\u0026#39; | grep \u0026#39;.jar\\]\u0026#39; | sed \u0026#39;s/\\[Loaded \\([^A-Z]*\\)[\\$A-Za-z0-9]* from .*\\]/\\1/g\u0026#39; | sort | uniq -c | sort You can run an instrumented version of your function which measure the execution time for all methods in the most interesting classes by running the following command:\njava -cp lab-1-replatform/no-di-framework-lambda/target/app.jar -javaagent:java-instrumentation-1.0-SNAPSHOT.jar=instrumentation.cfg Main You will a similar output like this (package names dropped), which gives you an idea where you spend most of the time:\nObjectMapper._readMapAndClose(JsonParser,JavaType) : 57 ObjectMapper.readValue(URL,Class) : 68 ObjectMapper._readMapAndClose(JsonParser,JavaType) : 82 ObjectMapper.readValue(InputStream,Class) : 83 CreatePetLambdaHandler.handleRequest(APIGatewayV2ProxyRequestEvent,Context) : 678 Deploy The Application To deploy the application, run the following command. It also exports the service endpoint url and the function ARN as environment variables for easy access:\nsam package --template-file lab-1-replatform/no-di-framework-lambda/template.yaml \\  --output-template-file lab-1-replatform/no-di-framework-lambda/packaged.yaml \\  --s3-bucket $SAM_ARTIFACT_BUCKET sam deploy --template-file lab-1-replatform/no-di-framework-lambda/packaged.yaml \\  --stack-name no-di-framework-lambda \\  --capabilities CAPABILITY_IAM export ENDPOINT=$(aws cloudformation describe-stacks \\  --stack-name no-di-framework-lambda \\  --query \u0026#39;Stacks[].Outputs[?OutputKey==`PetsApiServiceURL`].OutputValue\u0026#39; \\  --output text) export FUNCTION_ARN=$(aws cloudformation describe-stacks \\  --stack-name no-di-framework-lambda \\  --query \u0026#39;Stacks[].Outputs[?OutputKey==`CreatePetLambdaHandlerFunction`].OutputValue\u0026#39; \\  --output text) Memory Configuration We choose to with 1024 MB for the load and performance tests.\n  Run The Load Tests export JAVA_OPTS=\u0026#34;-DBASE_URL=$ENDPOINT\u0026#34; for i in {1..10}; do aws lambda update-function-configuration --function-name $FUNCTION_ARN --environment \u0026#34;Variables={TABLE_NAME=$PETS_TABLE,BUCKET_NAME=$PETS_BUCKET,KeyName1=KeyValue$i}\u0026#34;; gatling.sh --simulations-folder lab-1-replatform/no-di-framework-lambda/src/test/scala --simulation LoadTest --run-description \u0026#34;no-di-framework-lambda-run-$i\u0026#34;; done Run the Cold-Start Tests for i in {1..10}; do aws lambda update-function-configuration --function-name $FUNCTION_ARN --environment \u0026#34;Variables={TABLE_NAME=$PETS_TABLE,BUCKET_NAME=$PETS_BUCKET,KeyName1=KeyValue$i}\u0026#34;; curl -i -X POST -d \u0026#39;{\u0026#34;name\u0026#34;: \u0026#34;Max\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;dog\u0026#34;, \u0026#34;birthday\u0026#34;: \u0026#34;2010-11-03\u0026#34;, \u0026#34;medicalRecord\u0026#34;: \u0026#34;bla bla bla\u0026#34;}\u0026#39; $ENDPOINT/pet; done Result Overview Gatling Load Test Result (best out of 10)     Amazon X-Ray Cold-Start Trace (best out of 10)   Source Code Yo can find the source code here.\n"
},
{
	"uri": "/replatform/summary.html",
	"title": "Summary",
	"tags": [],
	"description": "",
	"content": "   Measurement MIN in ms P99 in ms FASTEST COLD-START in ms     Python in Lambda 46 156 581   Springboot in Lambda 41 11775 11500   Dagger2 in Lambda 36 4413 4700   no DI in Lambda 38 4492 4700    "
},
{
	"uri": "/optimize.html",
	"title": "Optimize",
	"tags": [],
	"description": "",
	"content": " Overview What are we doing here? Take the no DI framework measurements as baseline and see what else we can improve in terms of latency, cold-start and memory consumption.\nAWS Lambda Power Tuning Our goal is to run our AWS Lambda function with a performance optimized configuration, taking cost and scaling into account as well. We are using AWS Lambda Power Tuning to find the optimal configuration.\nThe easiest way is to install it via the AWS Serverless Application Repository by clicking at this link.\nA sample visualization with recommendations looks like this:\n"
},
{
	"uri": "/optimize/aws-java-sdk-v2.html",
	"title": "AWS Java SDK v2",
	"tags": [],
	"description": "",
	"content": " Analyze The Deployment Package To determine the package size of your function, run the following command in the bash window in your AWS Cloud9 IDE:\ncd ~/environment/lambda-on-java-workshop/labs ls -lh lab-2-optimize/aws-java-sdk-v2/target/app.jar It will report a package size of 13 MB.\nTo be able to run your function locally to analyse it in more detail, export your AWS_REGION as following:\nexport AWS_REGION=$(aws --profile default configure get region) To determine the number of classes which gets loaded to execute your function, run the following command in the bash window in your AWS Cloud9 IDE. Each application contains a helper Main class which invokes your AWS Lambda function locally:\n# Java 8 java -cp lab-2-optimize/aws-java-sdk-v2/target/app.jar -verbose:class com.aws.samples.petclinic.Main | grep \u0026#39;\\[Loaded\u0026#39; | wc -l# Java 11 java -cp lab-2-optimize/aws-java-sdk-v2/target/app.jar -verbose:class com.aws.samples.petclinic.Main | grep \u0026#39;\\[class,load\\]\u0026#39; | wc -l It will report 4921 classes got loaded to execute your AWS Lambda function.\nTo get a breakdown by package name, run the following command:\n# Java 8 java -cp lab-2-optimize/aws-java-sdk-v2/target/app.jar -verbose:class com.aws.samples.petclinic.Main | grep \u0026#39;\\[Loaded\u0026#39; | grep \u0026#39;.jar\\]\u0026#39; | sed \u0026#39;s/\\[Loaded \\([^A-Z]*\\)[\\$A-Za-z0-9]* from .*\\]/\\1/g\u0026#39; | sort | uniq -c | sort You can run an instrumented version of your function which measure the execution time for all methods in the most interesting classes by running the following command:\njava -cp lab-2-optimize/aws-java-sdk-v2/target/app.jar -javaagent:java-instrumentation-1.0-SNAPSHOT.jar=instrumentation.cfg com.aws.samples.petclinic.Main You will a similar output like this (package names dropped), which gives you an idea where you spend most of the time:\n Deploy The Application To deploy the application, run the following command. It also exports the service endpoint url and the function ARN as environment variables for easy access:\nsam package --template-file lab-2-optimize/aws-java-sdk-v2/template.yaml \\  --output-template-file lab-2-optimize/aws-java-sdk-v2/packaged.yaml \\  --s3-bucket $SAM_ARTIFACT_BUCKET sam deploy --template-file lab-2-optimize/aws-java-sdk-v2/packaged.yaml \\  --stack-name aws-java-sdk-v2 \\  --capabilities CAPABILITY_IAM export ENDPOINT=$(aws cloudformation describe-stacks \\  --stack-name aws-java-sdk-v2 \\  --query \u0026#39;Stacks[].Outputs[?OutputKey==`PetsApiServiceURL`].OutputValue\u0026#39; \\  --output text) export FUNCTION_ARN=$(aws cloudformation describe-stacks \\  --stack-name aws-java-sdk-v2 \\  --query \u0026#39;Stacks[].Outputs[?OutputKey==`CreatePetLambdaHandlerFunction`].OutputValue\u0026#39; \\  --output text) Memory Configuration We choose to go with 1024 MB for the load and performance tests.\nRun The Load Tests export JAVA_OPTS=\u0026#34;-DBASE_URL=$ENDPOINT\u0026#34; for i in {1..10}; do aws lambda update-function-configuration --function-name $FUNCTION_ARN --environment \u0026#34;Variables={TABLE_NAME=$PETS_TABLE,BUCKET_NAME=$PETS_BUCKET,KeyName1=KeyValue$i}\u0026#34;; gatling.sh --simulations-folder lab-2-optimize/aws-java-sdk-v2/src/test/scala --simulation LoadTest --run-description \u0026#34;aws-java-sdk-v2-run-$i\u0026#34;; done Run the Cold-Start Tests for i in {1..10}; do aws lambda update-function-configuration --function-name $FUNCTION_ARN --environment \u0026#34;Variables={TABLE_NAME=$PETS_TABLE,BUCKET_NAME=$PETS_BUCKET,KeyName1=KeyValue$i}\u0026#34;; curl -i -X POST -d \u0026#39;{\u0026#34;name\u0026#34;: \u0026#34;Max\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;dog\u0026#34;, \u0026#34;birthday\u0026#34;: \u0026#34;2010-11-03\u0026#34;, \u0026#34;medicalRecord\u0026#34;: \u0026#34;bla bla bla\u0026#34;}\u0026#39; $ENDPOINT/pet; done Result Overview Gatling Load Test Result (best out of 10)     Amazon X-Ray Cold-Start Trace (best out of 10)   Source Code Yo can find the source code here.\n"
},
{
	"uri": "/optimize/reducing-dependencies.html",
	"title": "Reducing Dependencies",
	"tags": [],
	"description": "",
	"content": " Analyze The Deployment Package To determine the package size of your function, run the following command in the bash window in your AWS Cloud9 IDE:\ncd ~/environment/lambda-on-java-workshop/labs ls -lh lab-2-optimize/reducing-dependencies/target/app.jar It will report a package size of 8 MB.\nTo be able to run your function locally to analyse it in more detail, export your AWS_REGION as following:\nexport AWS_REGION=$(aws --profile default configure get region) To determine the number of classes which gets loaded to execute your function, run the following command in the bash window in your AWS Cloud9 IDE. Each application contains a helper Main class which invokes your AWS Lambda function locally:\n# Java 8 java -cp lab-2-optimize/reducing-dependencies/target/app.jar -verbose:class com.aws.samples.petclinic.Main | grep \u0026#39;\\[Loaded\u0026#39; | wc -l# Java 11 java -cp lab-2-optimize/reducing-dependencies/target/app.jar -verbose:class com.aws.samples.petclinic.Main | grep \u0026#39;\\[class,load\\]\u0026#39; | wc -l It will report 4487 classes got loaded to execute your AWS Lambda function.\nTo get a breakdown by package name, run the following command:\n# Java 8 java -cp lab-2-optimize/reducing-dependencies/target/app.jar -verbose:class com.aws.samples.petclinic.Main | grep \u0026#39;\\[Loaded\u0026#39; | grep \u0026#39;.jar\\]\u0026#39; | sed \u0026#39;s/\\[Loaded \\([^A-Z]*\\)[\\$A-Za-z0-9]* from .*\\]/\\1/g\u0026#39; | sort | uniq -c | sort You can run an instrumented version of your function which measure the execution time for all methods in the most interesting classes by running the following command:\njava -cp lab-2-optimize/reducing-dependencies/target/app.jar -javaagent:java-instrumentation-1.0-SNAPSHOT.jar=instrumentation.cfg com.aws.samples.petclinic.Main You will a similar output like this (package names dropped), which gives you an idea where you spend most of the time:\n Deploy The Application To deploy the application, run the following command. It also exports the service endpoint url and the function ARN as environment variables for easy access:\nsam package --template-file lab-2-optimize/reducing-dependencies/template.yaml \\  --output-template-file lab-2-optimize/reducing-dependencies/packaged.yaml \\  --s3-bucket $SAM_ARTIFACT_BUCKET sam deploy --template-file lab-2-optimize/reducing-dependencies/packaged.yaml \\  --stack-name reducing-dependencies \\  --capabilities CAPABILITY_IAM export ENDPOINT=$(aws cloudformation describe-stacks \\  --stack-name reducing-dependencies \\  --query \u0026#39;Stacks[].Outputs[?OutputKey==`PetsApiServiceURL`].OutputValue\u0026#39; \\  --output text) export FUNCTION_ARN=$(aws cloudformation describe-stacks \\  --stack-name reducing-dependencies \\  --query \u0026#39;Stacks[].Outputs[?OutputKey==`CreatePetLambdaHandlerFunction`].OutputValue\u0026#39; \\  --output text) Memory Configuration We choose to go with 1024 MB for the load and performance tests.\n  Run The Load Tests export JAVA_OPTS=\u0026#34;-DBASE_URL=$ENDPOINT\u0026#34; for i in {1..10}; do aws lambda update-function-configuration --function-name $FUNCTION_ARN --environment \u0026#34;Variables={TABLE_NAME=$PETS_TABLE,BUCKET_NAME=$PETS_BUCKET,KeyName1=KeyValue$i}\u0026#34;; gatling.sh --simulations-folder lab-2-optimize/reducing-dependencies/src/test/scala --simulation LoadTest --run-description \u0026#34;reducing-dependencies-run-$i\u0026#34;; done Run the Cold-Start Tests for i in {1..10}; do aws lambda update-function-configuration --function-name $FUNCTION_ARN --environment \u0026#34;Variables={TABLE_NAME=$PETS_TABLE,BUCKET_NAME=$PETS_BUCKET,KeyName1=KeyValue$i}\u0026#34;; curl -i -X POST -d \u0026#39;{\u0026#34;name\u0026#34;: \u0026#34;Max\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;dog\u0026#34;, \u0026#34;birthday\u0026#34;: \u0026#34;2010-11-03\u0026#34;, \u0026#34;medicalRecord\u0026#34;: \u0026#34;bla bla bla\u0026#34;}\u0026#39; $ENDPOINT/pet; done Result Overview Gatling Load Test Result (best out of 10)     Amazon X-Ray Cold-Start Trace (best out of 10)   Source Code Yo can find the source code here.\n"
},
{
	"uri": "/optimize/packaging-mechanism.html",
	"title": "Packaging Mechanism",
	"tags": [],
	"description": "",
	"content": " Analyze The Deployment Package To determine the package size of your function, run the following command in the bash window in your AWS Cloud9 IDE:\ncd ~/environment/lambda-on-java-workshop/labs ls -lh lab-2-optimize/packaging-mechanism/target/app.jar It will report a package size of 8.5 MB.\nTo be able to run your function locally to analyse it in more detail, export your AWS_REGION as following:\nexport AWS_REGION=$(aws --profile default configure get region) To determine the number of classes which gets loaded to execute your function, run the following command in the bash window in your AWS Cloud9 IDE. Each application contains a helper Main class which invokes your AWS Lambda function locally:\n# Java 8 java -cp lab-2-optimize/packaging-mechanism/target/app.jar -verbose:class com.aws.samples.petclinic.Main | grep \u0026#39;\\[Loaded\u0026#39; | wc -l# Java 11 java -cp lab-2-optimize/packaging-mechanism/target/app.jar -verbose:class com.aws.samples.petclinic.Main | grep \u0026#39;\\[class,load\\]\u0026#39; | wc -l It will report 4983 classes got loaded to execute your AWS Lambda function.\nTo get a breakdown by package name, run the following command:\n# Java 8 java -cp lab-2-optimize/packaging-mechanism/target/app.jar -verbose:class com.aws.samples.petclinic.Main | grep \u0026#39;\\[Loaded\u0026#39; | grep \u0026#39;.jar\\]\u0026#39; | sed \u0026#39;s/\\[Loaded \\([^A-Z]*\\)[\\$A-Za-z0-9]* from .*\\]/\\1/g\u0026#39; | sort | uniq -c | sort You can run an instrumented version of your function which measure the execution time for all methods in the most interesting classes by running the following command:\njava -cp lab-2-optimize/packaging-mechanism/target/app.jar -javaagent:java-instrumentation-1.0-SNAPSHOT.jar=instrumentation.cfg com.aws.samples.petclinic.Main You will a similar output like this (package names dropped), which gives you an idea where you spend most of the time:\n Deploy The Application To deploy the application, run the following command. It also exports the service endpoint url and the function ARN as environment variables for easy access:\nsam package --template-file lab-2-optimize/packaging-mechanism/template.yaml \\  --output-template-file lab-2-optimize/packaging-mechanism/packaged.yaml \\  --s3-bucket $SAM_ARTIFACT_BUCKET sam deploy --template-file lab-2-optimize/packaging-mechanism/packaged.yaml \\  --stack-name packaging-mechanism \\  --capabilities CAPABILITY_IAM export ENDPOINT=$(aws cloudformation describe-stacks \\  --stack-name packaging-mechanism \\  --query \u0026#39;Stacks[].Outputs[?OutputKey==`PetsApiServiceURL`].OutputValue\u0026#39; \\  --output text) export FUNCTION_ARN=$(aws cloudformation describe-stacks \\  --stack-name packaging-mechanism \\  --query \u0026#39;Stacks[].Outputs[?OutputKey==`CreatePetLambdaHandlerFunction`].OutputValue\u0026#39; \\  --output text) Memory Configuration We choose to go with 1024 MB for the load and performance tests.\nRun The Load Tests export JAVA_OPTS=\u0026#34;-DBASE_URL=$ENDPOINT\u0026#34; for i in {1..10}; do aws lambda update-function-configuration --function-name $FUNCTION_ARN --environment \u0026#34;Variables={TABLE_NAME=$PETS_TABLE,BUCKET_NAME=$PETS_BUCKET,KeyName1=KeyValue$i}\u0026#34;; gatling.sh --simulations-folder lab-2-optimize/packaging-mechanism/src/test/scala --simulation LoadTest --run-description \u0026#34;packaging-mechanism-run-$i\u0026#34;; done Run the Cold-Start Tests for i in {1..10}; do aws lambda update-function-configuration --function-name $FUNCTION_ARN --environment \u0026#34;Variables={TABLE_NAME=$PETS_TABLE,BUCKET_NAME=$PETS_BUCKET,KeyName1=KeyValue$i}\u0026#34;; curl -i -X POST -d \u0026#39;{\u0026#34;name\u0026#34;: \u0026#34;Max\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;dog\u0026#34;, \u0026#34;birthday\u0026#34;: \u0026#34;2010-11-03\u0026#34;, \u0026#34;medicalRecord\u0026#34;: \u0026#34;bla bla bla\u0026#34;}\u0026#39; $ENDPOINT/pet; done Result Overview Gatling Load Test Result (best out of 10)     Amazon X-Ray Cold-Start Trace (best out of 10)   Source Code Yo can find the source code here.\n"
},
{
	"uri": "/optimize/jvm-options.html",
	"title": "JVM Options",
	"tags": [],
	"description": "",
	"content": " Analyze The Deployment Package To determine the package size of your function, run the following command in the bash window in your AWS Cloud9 IDE:\ncd ~/environment/lambda-on-java-workshop/labs ls -lh lab-2-optimize/jvm-options/target/app.jar It will report a package size of 13 MB.\nTo be able to run your function locally to analyse it in more detail, export your AWS_REGION as following:\nexport AWS_REGION=$(aws --profile default configure get region) To determine the number of classes which gets loaded to execute your function, run the following command in the bash window in your AWS Cloud9 IDE. Each application contains a helper Main class which invokes your AWS Lambda function locally:\n# Java 8 java -cp lab-2-optimize/jvm-options/target/app.jar -verbose:class com.aws.samples.petclinic.Main | grep \u0026#39;\\[Loaded\u0026#39; | wc -l# Java 11 java -cp lab-2-optimize/jvm-options/target/app.jar -verbose:class com.aws.samples.petclinic.Main | grep \u0026#39;\\[class,load\\]\u0026#39; | wc -l It will report 4920 classes got loaded to execute your AWS Lambda function.\nTo get a breakdown by package name, run the following command:\n# Java 8 java -cp lab-2-optimize/jvm-options/target/app.jar -verbose:class com.aws.samples.petclinic.Main | grep \u0026#39;\\[Loaded\u0026#39; | grep \u0026#39;.jar\\]\u0026#39; | sed \u0026#39;s/\\[Loaded \\([^A-Z]*\\)[\\$A-Za-z0-9]* from .*\\]/\\1/g\u0026#39; | sort | uniq -c | sort You can run an instrumented version of your function which measure the execution time for all methods in the most interesting classes by running the following command:\njava -cp lab-2-optimize/jvm-options/target/app.jar -javaagent:java-instrumentation-1.0-SNAPSHOT.jar=instrumentation.cfg com.aws.samples.petclinic.Main You will a similar output like this (package names dropped), which gives you an idea where you spend most of the time:\n Deploy The Application To deploy the application, run the following command. It also exports the service endpoint url and the function ARN as environment variables for easy access:\nsam package --template-file lab-2-optimize/jvm-options/template.yaml \\  --output-template-file lab-2-optimize/jvm-options/packaged.yaml \\  --s3-bucket $SAM_ARTIFACT_BUCKET sam deploy --template-file lab-2-optimize/jvm-options/packaged.yaml \\  --stack-name jvm-options \\  --capabilities CAPABILITY_IAM export ENDPOINT=$(aws cloudformation describe-stacks \\  --stack-name jvm-options \\  --query \u0026#39;Stacks[].Outputs[?OutputKey==`PetsApiServiceURL`].OutputValue\u0026#39; \\  --output text) export FUNCTION_ARN=$(aws cloudformation describe-stacks \\  --stack-name jvm-options \\  --query \u0026#39;Stacks[].Outputs[?OutputKey==`CreatePetLambdaHandlerFunction`].OutputValue\u0026#39; \\  --output text) Memory Configuration We choose to go with 1024 MB for the load and performance tests.\nRun The Load Tests export JAVA_OPTS=\u0026#34;-DBASE_URL=$ENDPOINT\u0026#34; for i in {1..10}; do aws lambda update-function-configuration --function-name $FUNCTION_ARN --environment \u0026#34;Variables={TABLE_NAME=$PETS_TABLE,BUCKET_NAME=$PETS_BUCKET,KeyName1=KeyValue$i}\u0026#34;; gatling.sh --simulations-folder lab-2-optimize/jvm-options/src/test/scala --simulation LoadTest --run-description \u0026#34;jvm-options-run-$i\u0026#34;; done Run the Cold-Start Tests for i in {1..10}; do aws lambda update-function-configuration --function-name $FUNCTION_ARN --environment \u0026#34;Variables={TABLE_NAME=$PETS_TABLE,BUCKET_NAME=$PETS_BUCKET,KeyName1=KeyValue$i}\u0026#34;; curl -i -X POST -d \u0026#39;{\u0026#34;name\u0026#34;: \u0026#34;Max\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;dog\u0026#34;, \u0026#34;birthday\u0026#34;: \u0026#34;2010-11-03\u0026#34;, \u0026#34;medicalRecord\u0026#34;: \u0026#34;bla bla bla\u0026#34;}\u0026#39; $ENDPOINT/pet; done Result Overview Gatling Load Test Result (best out of 10)     Amazon X-Ray Cold-Start Trace (best out of 10)   Source Code Yo can find the source code here.\n"
},
{
	"uri": "/optimize/handler-interface.html",
	"title": "Handler Interface",
	"tags": [],
	"description": "",
	"content": " Analyze The Deployment Package To determine the package size of your function, run the following command in the bash window in your AWS Cloud9 IDE:\ncd ~/environment/lambda-on-java-workshop/labs ls -lh lab-2-optimize/handler-interface/target/app.jar It will report a package size of 13 MB.\nTo be able to run your function locally to analyse it in more detail, export your AWS_REGION as following:\nexport AWS_REGION=$(aws --profile default configure get region) To determine the number of classes which gets loaded to execute your function, run the following command in the bash window in your AWS Cloud9 IDE. Each application contains a helper Main class which invokes your AWS Lambda function locally:\n# Java 8 java -cp lab-2-optimize/handler-interface/target/app.jar -verbose:class com.aws.samples.petclinic.Main | grep \u0026#39;\\[Loaded\u0026#39; | wc -l# Java 11 java -cp lab-2-optimize/handler-interface/target/app.jar -verbose:class com.aws.samples.petclinic.Main | grep \u0026#39;\\[class,load\\]\u0026#39; | wc -l It will report 4833 classes got loaded to execute your AWS Lambda function.\nTo get a breakdown by package name, run the following command:\n# Java 8 java -cp lab-2-optimize/handler-interface/target/app.jar -verbose:class com.aws.samples.petclinic.Main | grep \u0026#39;\\[Loaded\u0026#39; | grep \u0026#39;.jar\\]\u0026#39; | sed \u0026#39;s/\\[Loaded \\([^A-Z]*\\)[\\$A-Za-z0-9]* from .*\\]/\\1/g\u0026#39; | sort | uniq -c | sort You can run an instrumented version of your function which measure the execution time for all methods in the most interesting classes by running the following command:\njava -cp lab-2-optimize/handler-interface/target/app.jar -javaagent:java-instrumentation-1.0-SNAPSHOT.jar=instrumentation.cfg com.aws.samples.petclinic.Main You will a similar output like this (package names dropped), which gives you an idea where you spend most of the time:\n Deploy The Application To deploy the application, run the following command. It also exports the service endpoint url and the function ARN as environment variables for easy access:\nsam package --template-file lab-2-optimize/handler-interface/template.yaml \\  --output-template-file lab-2-optimize/handler-interface/packaged.yaml \\  --s3-bucket $SAM_ARTIFACT_BUCKET sam deploy --template-file lab-2-optimize/handler-interface/packaged.yaml \\  --stack-name handler-interface \\  --capabilities CAPABILITY_IAM export ENDPOINT=$(aws cloudformation describe-stacks \\  --stack-name handler-interface \\  --query \u0026#39;Stacks[].Outputs[?OutputKey==`PetsApiServiceURL`].OutputValue\u0026#39; \\  --output text) export FUNCTION_ARN=$(aws cloudformation describe-stacks \\  --stack-name handler-interface \\  --query \u0026#39;Stacks[].Outputs[?OutputKey==`CreatePetLambdaHandlerFunction`].OutputValue\u0026#39; \\  --output text) Memory Configuration We choose to go with 1024 MB for the load and performance tests.\nRun The Load Tests export JAVA_OPTS=\u0026#34;-DBASE_URL=$ENDPOINT\u0026#34; for i in {1..10}; do aws lambda update-function-configuration --function-name $FUNCTION_ARN --environment \u0026#34;Variables={TABLE_NAME=$PETS_TABLE,BUCKET_NAME=$PETS_BUCKET,KeyName1=KeyValue$i}\u0026#34;; gatling.sh --simulations-folder lab-2-optimize/handler-interface/src/test/scala --simulation LoadTest --run-description \u0026#34;handler-interface-run-$i\u0026#34;; done Run the Cold-Start Tests for i in {1..10}; do aws lambda update-function-configuration --function-name $FUNCTION_ARN --environment \u0026#34;Variables={TABLE_NAME=$PETS_TABLE,BUCKET_NAME=$PETS_BUCKET,KeyName1=KeyValue$i}\u0026#34;; curl -i -X POST -d \u0026#39;{\u0026#34;name\u0026#34;: \u0026#34;Max\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;dog\u0026#34;, \u0026#34;birthday\u0026#34;: \u0026#34;2010-11-03\u0026#34;, \u0026#34;medicalRecord\u0026#34;: \u0026#34;bla bla bla\u0026#34;}\u0026#39; $ENDPOINT/pet; done Result Overview Gatling Load Test Result (best out of 10)     Amazon X-Ray Cold-Start Trace (best out of 10)   Source Code Yo can find the source code here.\n"
},
{
	"uri": "/optimize/multithreading.html",
	"title": "Multithreading",
	"tags": [],
	"description": "",
	"content": " Analyze The Deployment Package To determine the package size of your function, run the following command in the bash window in your AWS Cloud9 IDE:\ncd ~/environment/lambda-on-java-workshop/labs ls -lh lab-2-optimize/multithreading/target/app.jar It will report a package size of 13 MB.\nTo be able to run your function locally to analyse it in more detail, export your AWS_REGION as following:\nexport AWS_REGION=$(aws --profile default configure get region) To determine the number of classes which gets loaded to execute your function, run the following command in the bash window in your AWS Cloud9 IDE. Each application contains a helper Main class which invokes your AWS Lambda function locally:\n# Java 8 java -cp lab-2-optimize/multithreading/target/app.jar -verbose:class com.aws.samples.petclinic.Main | grep \u0026#39;\\[Loaded\u0026#39; | wc -l# Java 11 java -cp lab-2-optimize/multithreading/target/app.jar -verbose:class com.aws.samples.petclinic.Main | grep \u0026#39;\\[class,load\\]\u0026#39; | wc -l It will report ??? classes got loaded to execute your AWS Lambda function.\nTo get a breakdown by package name, run the following command:\n# Java 8 java -cp lab-2-optimize/multithreading/target/app.jar -verbose:class com.aws.samples.petclinic.Main | grep \u0026#39;\\[Loaded\u0026#39; | grep \u0026#39;.jar\\]\u0026#39; | sed \u0026#39;s/\\[Loaded \\([^A-Z]*\\)[\\$A-Za-z0-9]* from .*\\]/\\1/g\u0026#39; | sort | uniq -c | sort You can run an instrumented version of your function which measure the execution time for all methods in the most interesting classes by running the following command:\njava -cp lab-2-optimize/multithreading/target/app.jar -javaagent:java-instrumentation-1.0-SNAPSHOT.jar=instrumentation.cfg com.aws.samples.petclinic.Main You will a similar output like this (package names dropped), which gives you an idea where you spend most of the time:\n Deploy The Application To deploy the application, run the following command. It also exports the service endpoint url and the function ARN as environment variables for easy access:\nsam package --template-file lab-2-optimize/multithreading/template.yaml \\  --output-template-file lab-2-optimize/multithreading/packaged.yaml \\  --s3-bucket $SAM_ARTIFACT_BUCKET sam deploy --template-file lab-2-optimize/multithreading/packaged.yaml \\  --stack-name multithreading \\  --capabilities CAPABILITY_IAM export ENDPOINT=$(aws cloudformation describe-stacks \\  --stack-name multithreading \\  --query \u0026#39;Stacks[].Outputs[?OutputKey==`PetsApiServiceURL`].OutputValue\u0026#39; \\  --output text) export FUNCTION_ARN=$(aws cloudformation describe-stacks \\  --stack-name multithreading \\  --query \u0026#39;Stacks[].Outputs[?OutputKey==`CreatePetLambdaHandlerFunction`].OutputValue\u0026#39; \\  --output text) Memory Configuration We choose to go with 1024 MB for the load and performance tests.\nRun The Load Tests export JAVA_OPTS=\u0026#34;-DBASE_URL=$ENDPOINT\u0026#34; for i in {1..10}; do aws lambda update-function-configuration --function-name $FUNCTION_ARN --environment \u0026#34;Variables={TABLE_NAME=$PETS_TABLE,BUCKET_NAME=$PETS_BUCKET,KeyName1=KeyValue$i}\u0026#34;; gatling.sh --simulations-folder lab-2-optimize/multithreading/src/test/scala --simulation LoadTest --run-description \u0026#34;multithreading-run-$i\u0026#34;; done Run the Cold-Start Tests for i in {1..10}; do aws lambda update-function-configuration --function-name $FUNCTION_ARN --environment \u0026#34;Variables={TABLE_NAME=$PETS_TABLE,BUCKET_NAME=$PETS_BUCKET,KeyName1=KeyValue$i}\u0026#34;; curl -i -X POST -d \u0026#39;{\u0026#34;name\u0026#34;: \u0026#34;Max\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;dog\u0026#34;, \u0026#34;birthday\u0026#34;: \u0026#34;2010-11-03\u0026#34;, \u0026#34;medicalRecord\u0026#34;: \u0026#34;bla bla bla\u0026#34;}\u0026#39; $ENDPOINT/pet; done Result Overview Gatling Load Test Result (best out of 10)     Amazon X-Ray Cold-Start Trace (best out of 10)   Source Code Yo can find the source code here.\n"
},
{
	"uri": "/optimize/prime-resources.html",
	"title": "Prime Resources",
	"tags": [],
	"description": "",
	"content": " Overview What are we doing here? \u0026hellip;\n"
},
{
	"uri": "/optimize/lambda-layers.html",
	"title": "Lambda Layers",
	"tags": [],
	"description": "",
	"content": " Overview What are we doing here? \u0026hellip;\n"
},
{
	"uri": "/optimize/java-11.html",
	"title": "Java 11",
	"tags": [],
	"description": "",
	"content": " Upgrading you AWS Lambda runtime to Amazon Corretto 11\nAnalyze The Deployment Package To determine the package size of your function, run the following command in the bash window in your AWS Cloud9 IDE:\ncd ~/environment/lambda-on-java-workshop/labs ls -lh lab-2-optimize/java-11/target/app.jar It will report a package size of 13 MB.\nTo be able to run your function locally to analyse it in more detail, export your AWS_REGION as following:\nexport AWS_REGION=$(aws --profile default configure get region) To determine the number of classes which gets loaded to execute your function, run the following command in the bash window in your AWS Cloud9 IDE. Each application contains a helper Main class which invokes your AWS Lambda function locally:\n# Java 8 java -cp lab-2-optimize/java-11/target/app.jar -verbose:class com.aws.samples.petclinic.Main | grep \u0026#39;\\[Loaded\u0026#39; | wc -l# Java 11 java -cp lab-2-optimize/java-11/target/app.jar -verbose:class com.aws.samples.petclinic.Main | grep \u0026#39;\\[class,load\\]\u0026#39; | wc -l It will report 4930 classes got loaded to execute your AWS Lambda function.\nTo get a breakdown by package name, run the following command:\n# Java 8 java -cp lab-2-optimize/java-11/target/app.jar -verbose:class com.aws.samples.petclinic.Main | grep \u0026#39;\\[Loaded\u0026#39; | grep \u0026#39;.jar\\]\u0026#39; | sed \u0026#39;s/\\[Loaded \\([^A-Z]*\\)[\\$A-Za-z0-9]* from .*\\]/\\1/g\u0026#39; | sort | uniq -c | sort You can run an instrumented version of your function which measure the execution time for all methods in the most interesting classes by running the following command:\njava -cp lab-2-optimize/java-11/target/app.jar -javaagent:java-instrumentation-1.0-SNAPSHOT.jar=instrumentation.cfg com.aws.samples.petclinic.Main You will a similar output like this (package names dropped), which gives you an idea where you spend most of the time:\n Deploy The Application To deploy the application, run the following command. It also exports the service endpoint url and the function ARN as environment variables for easy access:\nsam package --template-file lab-2-optimize/java-11/template.yaml \\  --output-template-file lab-2-optimize/java-11/packaged.yaml \\  --s3-bucket $SAM_ARTIFACT_BUCKET sam deploy --template-file lab-2-optimize/java-11/packaged.yaml \\  --stack-name java-11 \\  --capabilities CAPABILITY_IAM export ENDPOINT=$(aws cloudformation describe-stacks \\  --stack-name java-11 \\  --query \u0026#39;Stacks[].Outputs[?OutputKey==`PetsApiServiceURL`].OutputValue\u0026#39; \\  --output text) export FUNCTION_ARN=$(aws cloudformation describe-stacks \\  --stack-name java-11 \\  --query \u0026#39;Stacks[].Outputs[?OutputKey==`CreatePetLambdaHandlerFunction`].OutputValue\u0026#39; \\  --output text) Memory Configuration We choose to go with 1024 MB for the load and performance tests.\nRun The Load Tests export JAVA_OPTS=\u0026#34;-DBASE_URL=$ENDPOINT\u0026#34; for i in {1..10}; do aws lambda update-function-configuration --function-name $FUNCTION_ARN --environment \u0026#34;Variables={TABLE_NAME=$PETS_TABLE,BUCKET_NAME=$PETS_BUCKET,KeyName1=KeyValue$i}\u0026#34;; gatling.sh --simulations-folder lab-2-optimize/java-11/src/test/scala --simulation LoadTest --run-description \u0026#34;java-11-run-$i\u0026#34;; done Run the Cold-Start Tests for i in {1..10}; do aws lambda update-function-configuration --function-name $FUNCTION_ARN --environment \u0026#34;Variables={TABLE_NAME=$PETS_TABLE,BUCKET_NAME=$PETS_BUCKET,KeyName1=KeyValue$i}\u0026#34;; curl -i -X POST -d \u0026#39;{\u0026#34;name\u0026#34;: \u0026#34;Max\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;dog\u0026#34;, \u0026#34;birthday\u0026#34;: \u0026#34;2010-11-03\u0026#34;, \u0026#34;medicalRecord\u0026#34;: \u0026#34;bla bla bla\u0026#34;}\u0026#39; $ENDPOINT/pet; done Result Overview Gatling Load Test Result (best out of 10)     Amazon X-Ray Cold-Start Trace (best out of 10)   Source Code Yo can find the source code here.\n"
},
{
	"uri": "/optimize/corretto-crypto-provider.html",
	"title": "Amazon Corretto Crypto Provider",
	"tags": [],
	"description": "",
	"content": " Overview Using the Amazon Corretto Crypto Provider as the Java Cryptography Architecture (JCA) of choice\n"
},
{
	"uri": "/rearchitect.html",
	"title": "Rearchitect",
	"tags": [],
	"description": "",
	"content": " Overview Experimental\nIn these section, we will take a look at new and/or cutting edge technologies. All labs are based on the capability of GraalVM to build native images. These feature is available as Early Adopter technology, meaning it can be used in production and will be supported by Oracle as part of the Oracle GraalVM Enterprise Edition subscription, but is not covered by Oracles standard warranty.\n What are we doing here? bla\nWhat is GraalVM? bla\nCustomers\n"
},
{
	"uri": "/optimize/application-load-balancer.html",
	"title": "Application Load Balancer",
	"tags": [],
	"description": "",
	"content": " aws elbv2 create-target-group \\  --name PetsApiTargetGroup \\  --protocol https \\  --port 443 \\  --target-type lambda aws elbv2 register-targets \\  --target-group-arn arn:aws:elasticloadbalancing:us-west-2:123456789012:targetgroup/my-tcp-ip-targets/8518e899d173178f \\  --targets Id=arn:aws:lambda:us-west-2:123456789012:function:my-function aws lambda add-permission \\ --function-name lambda-function-arn-with-alias-name \\  --statement-id elb1 \\ --principal elasticloadbalancing.amazonaws.com \\ --action lambda:InvokeFunction \\ --source-arn target-group-arn Overview "
},
{
	"uri": "/optimize/summary.html",
	"title": "Summary",
	"tags": [],
	"description": "",
	"content": "   Measurement MIN in ms P99 in ms FASTEST COLD-START in ms     Python in Lambda 46 156 581   Springboot in Lambda 41 11775 11500   AWS Java SDK v2 40 4884 5000         Reduce Dependencies 37 4303 4400   Handler Interface 41 2880 4200   Packaging Mechanism 40 4942 5000   Multithreading      Java 11 42 5019 4900   JVM Options 41 5051 4900   Prime Resources      Lambda Layers      ALB      Coretto Crypto Provider       "
},
{
	"uri": "/rearchitect/graalvm.html",
	"title": "GraalVM",
	"tags": [],
	"description": "",
	"content": " Analyze The Deployment Package To determine the package size of your function, run the following command in the bash window in your AWS Cloud9 IDE:\ncd ~/environment/lambda-on-java-workshop/labs ls -lh lab-3-rearchitect/graalvm/target/function.zip It will report a package size of 9,3 MB.\nDeploy The Application To deploy the application, run the following command. It also exports the service endpoint url and the function ARN as environment variables for easy access:\nsam package --template-file lab-3-rearchitect/graalvm/template.yaml \\  --output-template-file lab-3-rearchitect/graalvm/packaged.yaml \\  --s3-bucket $SAM_ARTIFACT_BUCKET sam deploy --template-file lab-3-rearchitect/graalvm/packaged.yaml \\  --stack-name graalvm \\  --capabilities CAPABILITY_IAM export ENDPOINT=$(aws cloudformation describe-stacks \\  --stack-name graalvm \\  --query \u0026#39;Stacks[].Outputs[?OutputKey==`PetsApiServiceURL`].OutputValue\u0026#39; \\  --output text) export FUNCTION_ARN=$(aws cloudformation describe-stacks \\  --stack-name graalvm \\  --query \u0026#39;Stacks[].Outputs[?OutputKey==`CreatePetLambdaHandlerFunction`].OutputValue\u0026#39; \\  --output text) Memory Configuration TODO\nRun The Load Tests export JAVA_OPTS=\u0026#34;-DBASE_URL=$ENDPOINT\u0026#34; for i in {1..10}; do aws lambda update-function-configuration --function-name $FUNCTION_ARN --environment \u0026#34;Variables={TABLE_NAME=$PETS_TABLE,BUCKET_NAME=$PETS_BUCKET,KeyName1=KeyValue$i}\u0026#34;; gatling.sh --simulations-folder lab-3-rearchitect/graalvm/src/test/scala --simulation LoadTest --run-description \u0026#34;graalvm-run-$i\u0026#34;; done Run the Cold-Start Tests for i in {1..10}; do aws lambda update-function-configuration --function-name $FUNCTION_ARN --environment \u0026#34;Variables={TABLE_NAME=$PETS_TABLE,BUCKET_NAME=$PETS_BUCKET,KeyName1=KeyValue$i}\u0026#34;; curl -i -X POST -d \u0026#39;{\u0026#34;name\u0026#34;: \u0026#34;Max\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;dog\u0026#34;, \u0026#34;birthday\u0026#34;: \u0026#34;2010-11-03\u0026#34;, \u0026#34;medicalRecord\u0026#34;: \u0026#34;bla bla bla\u0026#34;}\u0026#39; $ENDPOINT/pet; done Result Overview Gatling Load Test Result (best out of 10)     Amazon X-Ray Cold-Start Trace (best out of 10)   Source Code Yo can find the source code here.\n"
},
{
	"uri": "/rearchitect/summary.html",
	"title": "Summary",
	"tags": [],
	"description": "",
	"content": "   Measurement MIN in ms P99 in ms FASTEST COLD-START in ms     Python in Lambda 46 156 581   Springboot in Lambda 41 11775 11500   GraalVM in Lambda 33 96 410    "
},
{
	"uri": "/clean-up.html",
	"title": "Clean-Up",
	"tags": [],
	"description": "",
	"content": " Tear-down and remove all resources Customers\n"
},
{
	"uri": "/categories.html",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/set-up/eu-central-1.html",
	"title": "Ireland",
	"tags": [],
	"description": "",
	"content": "Create your AWS Cloud9 Environment by launching this CloudFormation template in Frankfurt, with clicking on the below Launch button.\n   AWS CloudFormation launch template Launch in Frankfurt     AWS Cloud9 IDE  Launch     "
},
{
	"uri": "/set-up/eu-west-1.html",
	"title": "Ireland",
	"tags": [],
	"description": "",
	"content": "Create your AWS Cloud9 Environment by launching this CloudFormation template in Ireland, with clicking on the below Launch button.\n   AWS CloudFormation launch template Launch in Ireland     AWS Cloud9 IDE  Launch     "
},
{
	"uri": "/set-up/us-west-2.html",
	"title": "Oregon",
	"tags": [],
	"description": "",
	"content": "Create your AWS Cloud9 Environment by launching this CloudFormation template in Oregon, with clicking on the below Launch button.\n   AWS CloudFormation launch template Launch in Oregon     AWS Cloud9 IDE  Launch     "
},
{
	"uri": "/tags.html",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]